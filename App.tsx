import React, { useState, useEffect, useCallback } from "react";
import { Youtube, Calculator, StickyNote, Music, Globe, Sparkles } from "lucide-react";

// UI Components
import Sidebar from "./components/Sidebar";
import Header from "./components/Header";
import TitleBar from "./components/TitleBar";
import NotificationSystem from "./components/Notifications";
import TopNavBar from "./components/TopNavBar";
import { Dock } from "./components/Dock";
import { AllAppsPopup } from "./components/AllAppsPopup";
import { ContextMenu } from "./components/ContextMenu";
import { Window } from "./components/Window";
import { BrowserApp } from "./components/BrowserApp";
import { CalculatorApp } from "./components/CalculatorApp";
import EnvironmentStoreApp from "./components/EnvironmentStoreApp";

// Pages
import Dashboard from "./components/Dashboard";
import Tasks from "./components/TasksPage";
import GoalsPage from "./components/GoalsPage";
import HabitsPage from "./components/HabitsPage";
import CalendarPage from "./components/CalendarPage";
import FocusPage from "./components/FocusPage";
import SettingsPage from "./components/SettingsPage";
import ChatPage from "./components/ChatPage";
import ChatApp from "./components/ChatApp";
import LoginPage from "./components/LoginPage";
import SignUpPage from "./components/SignUpPage";
import CompactView from "./components/CompactView";


// Stores
import { useAppStore } from "./store/useAppStore";
import { useSettingsStore } from "./store/useSettingsStore";
import { useSpotifyStore } from "./store/useSpotifyStore";
import { useMessageStore } from "./store/useMessageStore";
import { useCalendarStore } from "./store/useCalendarStore";
import { useFocusStore } from "./store/useFocusStore";
import { useGoalStore } from "./store/useGoalStore";
import { useHabitStore } from "./components/HabitsPage";
import { handleAuthRedirectIfPresent } from "./auth/spotifyAuth";
import { useFirebaseSync } from "./utils/firebaseSync";
import { playClickSound } from "./utils/clickSound";

// Animations
import { AnimatePresence, motion } from "framer-motion";

import LiveBackground from "./components/LiveBackground";
import StudySessionModal from './components/StudySessionModal';

import MigrationLoadingScreen from './components/MigrationLoadingScreen';
import { doc, onSnapshot, deleteDoc } from 'firebase/firestore';
import { db } from './config/firebase';
import { useMigrationStore } from './store/useMigrationStore';
import { useSuperFocus } from "./hooks/useSuperFocus";

const App: React.FC = () => {
  // üåô Navigation
  const activePage = useAppStore((s) => s.activePage);
  const setActivePage = useAppStore((s) => s.setActivePage);
  const compactMode = useAppStore((s) => s.compactMode);
  const superFocus = useSuperFocus();

  // üéØ Window Management State
  const [openWindows, setOpenWindows] = useState<string[]>([]);
  const [minimizedWindows, setMinimizedWindows] = useState<string[]>([]);
  const [activeWindow, setActiveWindow] = useState<string | null>(null);
  const [iconPositions, setIconPositions] = useState<Record<string, DOMRect>>({});
  const [windowZIndices, setWindowZIndices] = useState<Record<string, number>>({});
  const [windowModes, setWindowModes] = useState<Record<string, 'normal' | 'maximized' | 'left' | 'right'>>({});
  const [windowPositions, setWindowPositions] = useState<Record<string, { x: number; y: number }>>({});
  const baseZIndex = 1000;

  // ‚ú® All Apps Popup State
  const [isAllAppsOpen, setIsAllAppsOpen] = useState(false);
  const [contextMenu, setContextMenu] = useState<{
    isOpen: boolean;
    position: { x: number; y: number };
    appId: string | null;
  }>({ isOpen: false, position: { x: 0, y: 0 }, appId: null });

  // Get pinned apps from store
  const pinnedAppIds = useAppStore((s) => s.pinnedAppIds);
  const togglePinApp = useAppStore((s) => s.togglePinApp);

  // üéØ Mini-Apps Configuration
  const dockApps = React.useMemo(() => [
    {
      id: 'browser',
      title: 'Browser',
      icon: Globe,
      width: 1024,
      height: 768,
      component: <BrowserApp />
    },
    {
      id: 'youtube',
      title: 'YouTube',
      icon: Youtube,
      width: 800,
      height: 600,
      component: (
        <webview
          src="https://www.youtube.com"
          className="w-full h-full border-0"
          allowpopups
          webpreferences="contextIsolation=yes, nodeIntegration=no, sandbox=yes"
        />
      )
    },
    {
      id: 'calculator',
      title: 'Calculator',
      icon: Calculator,
      width: 320,
      height: 480,
      component: <CalculatorApp />
    },
    {
      id: 'notes',
      title: 'Notes',
      icon: StickyNote,
      width: 600,
      height: 500,
      component: (
        <div className="p-4 h-full bg-yellow-50">
          <textarea
            className="w-full h-full bg-transparent border-0 resize-none focus:outline-none text-gray-800"
            placeholder="Start typing your notes..."
          />
        </div>
      )
    },
    {
      id: 'music',
      title: 'Music',
      icon: Music,
      width: 400,
      height: 500,
      component: (
        <div className="flex items-center justify-center h-full bg-gradient-to-br from-purple-600 to-pink-600 text-white">
          <div className="text-center">
            <Music size={48} className="mx-auto mb-4" />
            <p className="text-sm">Music Player coming soon</p>
          </div>
        </div>
      )
    },
    {
      id: 'environment-store',
      title: 'Environment Store',
      icon: Sparkles,
      width: 1200,
      height: 800,
      component: <EnvironmentStoreApp />
    },
  ], []);

  // Filter dock apps to show only pinned ones (or all if none pinned)
  const visibleDockApps = React.useMemo(() => {
    if (pinnedAppIds.length === 0) {
      // Default to first 6 apps if none pinned
      return dockApps.slice(0, 6);
    }
    return dockApps.filter(app => pinnedAppIds.includes(app.id));
  }, [dockApps, pinnedAppIds]);

  // Handle window actions
  const handleAppClick = useCallback((appId: string) => {
    if (minimizedWindows.includes(appId)) {
      // Un-minimize
      setMinimizedWindows(prev => prev.filter(id => id !== appId));
      setActiveWindow(appId);
    } else if (openWindows.includes(appId)) {
      // Focus if already open
      setActiveWindow(appId);
      // Bring to front
      setWindowZIndices(prev => {
        const maxZ = Math.max(...Object.values(prev), baseZIndex);
        return { ...prev, [appId]: maxZ + 1 };
      });
    } else {
      // Open new window
      setOpenWindows(prev => [...prev, appId]);
      setActiveWindow(appId);
      setWindowZIndices(prev => {
        const maxZ = Math.max(...Object.values(prev), baseZIndex);
        return { ...prev, [appId]: maxZ + 1 };
      });
    }
  }, [minimizedWindows, openWindows, windowZIndices]);

  const handleWindowClose = useCallback((appId: string) => {
    setOpenWindows(prev => prev.filter(id => id !== appId));
    setMinimizedWindows(prev => prev.filter(id => id !== appId));
    setActiveWindow(prev => prev === appId ? null : prev);
  }, []);

  const handleWindowMinimize = useCallback((appId: string) => {
    setMinimizedWindows(prev => [...prev, appId]);
    setActiveWindow(prev => prev === appId ? null : prev);
  }, []);



  const handleWindowMaximize = useCallback((appId: string) => {
    setWindowModes(prev => ({
      ...prev,
      [appId]: prev[appId] === 'maximized' ? 'normal' : 'maximized'
    }));
  }, []);

  const handleWindowSnap = useCallback((appId: string, mode: 'left' | 'right' | 'normal') => {
    setWindowModes(prev => ({
      ...prev,
      [appId]: mode
    }));
  }, []);

  const handleWindowMove = useCallback((appId: string, x: number, y: number) => {
    setWindowPositions(prev => ({
      ...prev,
      [appId]: { x, y }
    }));
  }, []);

  const handleWindowFocus = useCallback((appId: string) => {
    setActiveWindow(appId);
    setWindowZIndices(prev => {
      const maxZ = Math.max(...Object.values(prev), baseZIndex);
      // Only update if not already top
      if (prev[appId] === maxZ) return prev;
      return { ...prev, [appId]: maxZ + 1 };
    });
  }, []);

  // üåô Migration state
  const isMigrating = useMigrationStore((s) => s.isMigrating);

  // Study Session & Personal Call State
  const { studySession, setStudySessionOpen, handleIncomingCall, personalCall, handleIncomingPersonalCall } = useAppStore();

  const [isSignup, setIsSignup] = useState(false);

  // üåô Messaging store
  const currentUser = useMessageStore((s) => s.currentUser);
  const activeUserId = useMessageStore((s) => s.activeUserId);
  const subscribeToUsers = useMessageStore((s) => s.subscribeToUsers);
  const subscribeToMessages = useMessageStore((s) => s.subscribeToMessages);
  const initAuth = useMessageStore((s) => s.initAuth);
  const isLoading = useMessageStore((s) => s.isLoading);

  // üåô Mobile drawer
  const [isMobileDrawerOpen, setIsMobileDrawerOpen] = useState(true);

  // üåô TopNav Server Tabs
  const [activeServerId, setActiveServerId] = useState("home");

  // üéµ Click Sound Setting
  const clickSoundEnabled = useSettingsStore((s) => s.clickSoundEnabled);

  // Theme Sync
  useEffect(() => {
    const settings = useSettingsStore.getState();
    const stop = settings.startSystemThemeSync();
    settings.applyThemeToDom();
    return () => stop();
  }, []);

  // üéµ Global Click Sound Listener
  useEffect(() => {
    if (!clickSoundEnabled) return;

    const handleClick = () => {
      playClickSound();
    };

    // Add global click listener
    document.addEventListener('click', handleClick);

    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, [clickSoundEnabled]);

  // üî• Firebase Store Sync (only when user is logged in)
  useFirebaseSync({
    collectionName: 'app-state',
    store: useAppStore,
    selector: (state) => ({
      tasks: state.tasks,
      sessionHistory: state.sessionHistory,
      focusMode: state.focusMode,
      timerRemaining: state.timerRemaining,
      activePage: state.activePage,
      spotify: state.spotify,
    }),
  });

  useFirebaseSync({
    collectionName: 'calendar-state',
    store: useCalendarStore,
  });

  useFirebaseSync({
    collectionName: 'settings-state',
    store: useSettingsStore,
  });

  useFirebaseSync({
    collectionName: 'focus-state',
    store: useFocusStore,
    selector: (state) => ({
      environment: state.environment,
      tasks: state.tasks,
      focusMode: state.focusMode,
      // Don't sync functions or runtime state
    }),
  });

  // Goals Firebase Sync
  useFirebaseSync({
    collectionName: 'goals-state',
    store: useGoalStore,
  });

  // Habits Firebase Sync
  useFirebaseSync({
    collectionName: 'habits-state',
    store: useHabitStore,
  });

  // Initialize Auth
  useEffect(() => {
    const unsub = initAuth();

    // Safety timeout: if Firebase takes too long, stop loading
    const timer = setTimeout(() => {
      if (useMessageStore.getState().isLoading) {
        useMessageStore.setState({ isLoading: false });
      }
    }, 4000);

    return () => {
      unsub();
      clearTimeout(timer);
    };
  }, []);

  // Messaging Subscriptions
  // 1. Subscribe to Users
  useEffect(() => {
    if (!currentUser) return;
    const unsubscribe = subscribeToUsers();
    return () => unsubscribe();
  }, [currentUser]);

  // 2. Subscribe to Active Chat Messages
  useEffect(() => {
    if (currentUser && activeUserId) {
      const unsub = subscribeToMessages(activeUserId);
      return () => unsub();
    }
  }, [currentUser, activeUserId]);

  // 3. Subscribe to Notifications (Global)
  const { subscribeToNotifications } = useMessageStore();
  useEffect(() => {
    if (currentUser) {
      const unsub = subscribeToNotifications();
      return () => unsub();
    }
  }, [currentUser]);

  // 4. Listen for incoming calls (Global)
  useEffect(() => {
    if (!currentUser) return;

    // We listen to a specific document for incoming calls
    // This requires a backend trigger or client-side write to `users/{userId}/incoming_call`
    // Since we implemented `sendMessage` with `call_invite` type, we can listen to that?
    // But `sendMessage` writes to `chats/{chatId}/messages`.

    // Ideally, we should have a separate listener for "invites".
    // For now, let's assume the `StudySessionModal` handles the "active" state.
    // But for "ringing", we need to know when someone calls us.

    // If we rely on `call_invite` messages, the user has to be in the chat to see it.
    // To make it global, we need a global listener.

    // Let's implement a simple listener on the user's profile for a "currentCall" field?
    // Or just rely on the chat message notification?

    // Given the constraints, let's stick to the chat message for now.
    // If the user gets a message with type 'call_invite', we could trigger the modal?
    // But we don't have a global message listener for ALL chats.

    // Let's add a listener to `users/{userId}/incoming_call/active`
    const callRef = doc(db, "users", currentUser.id, "incoming_call", "active");
    const unsub = onSnapshot(callRef, (snap) => {
      if (snap.exists()) {
        const data = snap.data();
        if (data && data.sessionCode && !studySession.isOpen) {
          handleIncomingCall(data.sessionCode, data.callerId);
        }
      }
    });

    return () => unsub();
  }, [currentUser, studySession.isOpen]);

  // 5. Listen for incoming personal calls (Global)
  useEffect(() => {
    if (!currentUser) return;

    const callRef = doc(db, "users", currentUser.id, "incoming_personal_call", "active");
    const unsub = onSnapshot(callRef, (snap) => {
      if (snap.exists()) {
        const data = snap.data();
        if (data && data.callId && !personalCall.isActive) {
          // Check if the call is recent (within 5 minutes)
          const callTimestamp = data.timestamp || 0;
          const now = Date.now();
          const fiveMinutesInMs = 5 * 60 * 1000;

          if (now - callTimestamp < fiveMinutesInMs) {
            // Call is recent, show the modal
            handleIncomingPersonalCall(data.callerId, data.callId);
          } else {
            // Call is too old (stale), delete it
            console.log('Ignoring stale call from', new Date(callTimestamp));
            deleteDoc(callRef).catch(err => console.error('Error deleting stale call:', err));
          }
        }
      }
    });

    return () => unsub();
  }, [currentUser, personalCall.isActive]);

  // Tick timer
  useEffect(() => {
    const interval = setInterval(() => useAppStore.getState().tick(), 1000);
    return () => clearInterval(interval);
  }, []);

  // Spotify OAuth
  const acceptTokens = useSpotifyStore((s) => s.acceptOAuthTokens);
  useEffect(() => {
    handleAuthRedirectIfPresent(acceptTokens);
  }, [acceptTokens]);

  // üîí SUPER FOCUS KEYBOARD LOCKDOWN
  // Block ALL keyboard input except ESC key when in Super Focus mode
  useEffect(() => {
    if (!superFocus.isActive) return;

    const blockKeyboard = (event: KeyboardEvent) => {
      // Allow ONLY Escape key to work (for exiting Super Focus)
      if (event.key === 'Escape') {
        return; // Let Escape through - Electron handles it
      }

      // Block everything else
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
    };

    // Attach to all keyboard events at capture phase (highest priority)
    document.addEventListener('keydown', blockKeyboard, true);
    document.addEventListener('keyup', blockKeyboard, true);
    document.addEventListener('keypress', blockKeyboard, true);

    return () => {
      document.removeEventListener('keydown', blockKeyboard, true);
      document.removeEventListener('keyup', blockKeyboard, true);
      document.removeEventListener('keypress', blockKeyboard, true);
    };
  }, [superFocus.isActive]);

  // Page switcher
  const renderContent = useCallback(() => {
    switch (activePage) {
      case "Dashboard": return <Dashboard />;
      case "Tasks": return <Tasks />;
      case "Goals": return <GoalsPage />;
      case "Habits": return <HabitsPage />;
      case "Calendar": return <CalendarPage />;
      case "Focus": return <FocusPage />;
      case "Messages": return <ChatApp />;
      case "Settings": return <SettingsPage />;
      default:
        return (
          <div className="p-6 bg-[#1C1C1E] rounded-xl border border-gray-700 text-gray-400">
            Page not implemented.
          </div>
        );
    }
  }, [activePage]);

  // LOADING STATE
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-[#111217]">
        <div className="w-10 h-10 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col text-white relative">
      {/* üîÑ Migration Loading Screen */}
      <MigrationLoadingScreen isVisible={isMigrating} />

      {/* üåø Live Environment Background (Fixed z-0) */}
      <LiveBackground />

      {/* Auth Flow */}
      {!currentUser ? (
        <div className="relative z-10 min-h-screen flex items-center justify-center">
          {isSignup ? (
            <SignUpPage onNavigateToLogin={() => setIsSignup(false)} />
          ) : (
            <LoginPage
              onLoginSuccess={() => setActivePage("Dashboard")}
              onNavigateToSignup={() => setIsSignup(true)}
            />
          )}
        </div>
      ) : compactMode ? (
        /* Compact View Mode - render above background */
        <div className="relative z-20">
          <CompactView />
        </div>
      ) : (
        /* Content Wrapper (z-10) */
        <div className="relative z-10 flex flex-col h-full min-h-screen">
          {/* Hide TitleBar in Super Focus Mode */}
          <AnimatePresence>
            {!superFocus.isActive && (
              <motion.div
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3 }}
                className="z-50"
              >
                <TitleBar />
              </motion.div>
            )}
          </AnimatePresence>
          <NotificationSystem />

          {/* Hide TopNavBar in Super Focus Mode */}
          <AnimatePresence>
            {!superFocus.isActive && (
              <motion.div
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ duration: 0.3, delay: 0.1 }}
              >
                <TopNavBar
                  activeServer={activeServerId}
                  onSelect={(id) => setActiveServerId(id)}
                />
              </motion.div>
            )}
          </AnimatePresence>

          <div className="flex flex-1 overflow-hidden pt-4 relative">

            {/* Hide Sidebar in Super Focus Mode */}
            <AnimatePresence>
              {!superFocus.isActive && (
                <motion.div
                  initial={{ opacity: 0, x: -50 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: -50 }}
                  transition={{ duration: 0.3, delay: 0.2 }}
                  className="h-full"
                >
                  <Sidebar
                    activeItem={activePage}
                    onSelect={(page) => {
                      setActivePage(page);
                      setIsMobileDrawerOpen(false);
                    }}
                    isMobileDrawerOpen={isMobileDrawerOpen}
                    setIsMobileDrawerOpen={setIsMobileDrawerOpen}
                  />
                </motion.div>
              )}
            </AnimatePresence>


            <main className="flex-1 overflow-y-auto w-full">
              <div className={`max-w-full ${activePage === 'Messages' ? 'px-0 pt-0 pb-0 md:pl-20' : 'px-6 lg:px-10 pt-6 pb-5'} transition-all duration-500 ${!superFocus.isActive && activePage !== 'Messages' ? 'md:pl-24' : 'pl-0'}`}>
                {/* Hide Header in Super Focus Mode or Messages Page */}
                <AnimatePresence>
                  {!superFocus.isActive && activePage !== 'Messages' && (
                    <motion.div
                      initial={{ opacity: 0, y: -20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: -20 }}
                      transition={{ duration: 0.3, delay: 0.3 }}
                    >
                      <Header
                        currentPage={activePage}
                        setSidebarOpen={setIsMobileDrawerOpen}
                      />
                    </motion.div>
                  )}
                </AnimatePresence>

                {/* üöÄ ANIMATED PAGE TRANSITION START */}
                {/* üçÉ NATURAL / SUBTLE DRIFT */}
                <AnimatePresence mode="wait">
                  <motion.div
                    key={activePage}
                    initial={{ opacity: 0, y: 8 }}   // Starts 8px down, invisible
                    animate={{ opacity: 1, y: 0 }}   // Floats up to natural position
                    exit={{ opacity: 0, y: -8 }}     // Floats up and vanishes
                    transition={{
                      duration: 0.2,
                      ease: "easeOut"                // Natural deceleration
                    }}
                    className={activePage === 'Messages' ? 'w-full h-full' : 'w-full h-full'}
                  >
                    {renderContent()}
                  </motion.div>
                </AnimatePresence>
                {/* üöÄ ANIMATED PAGE TRANSITION END */}

              </div>
            </main>


          </div>

          {/* Chat overlay */}
          <AnimatePresence>
            {activeUserId && <ChatPage />}
          </AnimatePresence>

          {/* Study Session Modal (Global) */}
          <StudySessionModal />

          {/* Personal Call Modal (Global) */}

          {/* üöÄ Mini-App Windows */}
          {dockApps.map(app => (
            <Window
              key={app.id}
              app={app}
              isOpen={openWindows.includes(app.id)}
              isMinimized={minimizedWindows.includes(app.id)}
              isActive={activeWindow === app.id}
              zIndex={windowZIndices[app.id] || baseZIndex}
              iconRect={iconPositions[app.id]}
              mode={windowModes[app.id] || 'normal'}
              position={windowPositions[app.id]}
              onClose={() => handleWindowClose(app.id)}
              onMinimize={() => handleWindowMinimize(app.id)}
              onMaximize={() => handleWindowMaximize(app.id)}
              onSnap={(mode) => handleWindowSnap(app.id, mode)}
              onMove={(x, y) => handleWindowMove(app.id, x, y)}
              onFocus={() => handleWindowFocus(app.id)}
            />
          ))}

          {/* üöÄ Dock */}
          <AnimatePresence>
            {!superFocus.isActive && (
              <Dock
                apps={visibleDockApps}
                openAppIds={openWindows}
                activeAppId={activeWindow}
                onAppClick={handleAppClick}
                onLayout={setIconPositions}
                onAllAppsClick={() => setIsAllAppsOpen(true)}
                onAppContextMenu={(e, app) => {
                  e.preventDefault();
                  setContextMenu({
                    isOpen: true,
                    position: { x: e.clientX, y: e.clientY },
                    appId: app.id
                  });
                }}
              />
            )}
          </AnimatePresence>

          {/* All Apps Popup */}
          <AllAppsPopup
            isOpen={isAllAppsOpen}
            apps={dockApps}
            pinnedAppIds={pinnedAppIds}
            onClose={() => setIsAllAppsOpen(false)}
            onAppClick={handleAppClick}
            onContextMenu={(e, app) => {
              e.preventDefault();
              setContextMenu({
                isOpen: true,
                position: { x: e.clientX, y: e.clientY },
                appId: app.id
              });
            }}
          />

          {/* Context Menu */}
          <ContextMenu
            isOpen={contextMenu.isOpen}
            position={contextMenu.position}
            isPinned={contextMenu.appId ? pinnedAppIds.includes(contextMenu.appId) : false}
            onPin={() => {
              if (contextMenu.appId) {
                togglePinApp(contextMenu.appId);
              }
            }}
            onClose={() => setContextMenu({ isOpen: false, position: { x: 0, y: 0 }, appId: null })}
          />

        </div>
      )}
    </div>
  );
};

export default App;
